#!/usr/bin/env python3\n\"\"\"\nMedical Quality Assurance Hook\nEnsures all medical outputs meet clinical safety and accuracy standards\n\"\"\"\n\nimport json\nimport sys\nfrom typing import Dict, Any, List, Tuple\nimport logging\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nclass MedicalQualityAssurance:\n    \"\"\"\n    Comprehensive medical quality assurance for EKG simulation outputs\n    \"\"\"\n    \n    def __init__(self):\n        self.clinical_thresholds = {\n            'heart_rate': {'min': 20, 'max': 300},\n            'pr_interval': {'min': 80, 'max': 400},\n            'qrs_duration': {'min': 40, 'max': 200},\n            'qt_interval': {'min': 200, 'max': 600}\n        }\n        \n        self.critical_rhythms = [\n            'ventricular_tachycardia',\n            'ventricular_fibrillation',\n            'complete_heart_block',\n            'asystole'\n        ]\n        \n        self.rhythm_significance_map = {\n            'normal_sinus': 'normal',\n            'sinus_bradycardia': ['normal', 'monitor', 'urgent'],\n            'sinus_tachycardia': ['normal', 'monitor'],\n            'atrial_fibrillation': ['monitor', 'urgent'],\n            'ventricular_tachycardia': ['critical'],\n            'heart_block': ['monitor', 'urgent', 'critical']\n        }\n    \n    def validate_medical_analysis(self, medical_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        Comprehensive validation of medical analysis output\n        \"\"\"\n        errors = []\n        warnings = []\n        \n        # Validate required fields\n        required_fields = [\n            'rhythm_classification', 'heart_rate', 'conduction_timing',\n            'clinical_significance', 'chamber_coordination', 'intervals',\n            'pathophysiology', 'clinical_context'\n        ]\n        \n        for field in required_fields:\n            if field not in medical_data:\n                errors.append(f\"Missing required field: {field}\")\n        \n        if errors:\n            return self._create_validation_result('FAILED', errors, warnings)\n        \n        # Validate heart rate\n        heart_rate_validation = self._validate_heart_rate(medical_data)\n        if heart_rate_validation['errors']:\n            errors.extend(heart_rate_validation['errors'])\n        if heart_rate_validation['warnings']:\n            warnings.extend(heart_rate_validation['warnings'])\n        \n        # Validate conduction timing\n        timing_validation = self._validate_conduction_timing(medical_data)\n        if timing_validation['errors']:\n            errors.extend(timing_validation['errors'])\n        if timing_validation['warnings']:\n            warnings.extend(timing_validation['warnings'])\n        \n        # Validate clinical significance\n        significance_validation = self._validate_clinical_significance(medical_data)\n        if significance_validation['errors']:\n            errors.extend(significance_validation['errors'])\n        if significance_validation['warnings']:\n            warnings.extend(significance_validation['warnings'])\n        \n        # Validate chamber coordination logic\n        coordination_validation = self._validate_chamber_coordination(medical_data)\n        if coordination_validation['errors']:\n            errors.extend(coordination_validation['errors'])\n        \n        # Validate interval measurements\n        interval_validation = self._validate_intervals(medical_data)\n        if interval_validation['errors']:\n            errors.extend(interval_validation['errors'])\n        if interval_validation['warnings']:\n            warnings.extend(interval_validation['warnings'])\n        \n        # Critical safety checks\n        safety_validation = self._validate_medical_safety(medical_data)\n        if safety_validation['errors']:\n            errors.extend(safety_validation['errors'])\n        \n        if errors:\n            return self._create_validation_result('FAILED', errors, warnings)\n        elif warnings:\n            return self._create_validation_result('WARNING', [], warnings)\n        else:\n            return self._create_validation_result('PASSED', [], [])\n    \n    def validate_visualization_sync(self, medical_data: Dict[str, Any], \n                                  visual_config: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        Validate that 3D visualization accurately reflects medical data\n        \"\"\"\n        errors = []\n        warnings = []\n        \n        # Validate animation timing matches cardiac cycle\n        if 'animation_timing' in visual_config:\n            medical_cycle = medical_data.get('conduction_timing', {}).get('cardiac_cycle_ms', 0)\n            visual_cycle = visual_config['animation_timing'].get('cycle_duration_ms', 0)\n            \n            timing_tolerance = 50  # 50ms tolerance\n            if abs(medical_cycle - visual_cycle) > timing_tolerance:\n                errors.append(f\"Animation cycle ({visual_cycle}ms) doesn't match medical cycle ({medical_cycle}ms)\")\n        \n        # Validate electrical sequence timing\n        if 'electrical_sequence' in visual_config.get('animation_timing', {}):\n            medical_timing = medical_data.get('conduction_timing', {})\n            visual_timing = visual_config['animation_timing']['electrical_sequence']\n            \n            # Check SA to AV delay\n            if 'sa_to_av_delay' in medical_timing and 'av_conduction' in visual_timing:\n                medical_delay = medical_timing['sa_to_av_delay']\n                visual_delay = visual_timing['av_conduction']\n                \n                if abs(medical_delay - visual_delay) > 20:  # 20ms tolerance\n                    errors.append(f\"SA-AV conduction timing mismatch: medical={medical_delay}ms, visual={visual_delay}ms\")\n        \n        # Validate chamber contraction reflects rhythm\n        rhythm = medical_data.get('rhythm_classification', '')\n        chamber_config = visual_config.get('chamber_contraction', {})\n        \n        if rhythm == 'atrial_fibrillation':\n            atrial_intensity = chamber_config.get('atrial_contraction_intensity', 1.0)\n            if atrial_intensity > 0.2:  # Minimal atrial contraction in AFib\n                warnings.append(f\"Atrial contraction intensity too high for AFib: {atrial_intensity}\")\n        \n        if rhythm in self.critical_rhythms:\n            ventricular_intensity = chamber_config.get('ventricular_contraction_intensity', 0)\n            if ventricular_intensity < 0.8:  # Should maintain some ventricular function\n                warnings.append(f\"Ventricular contraction intensity low for {rhythm}: {ventricular_intensity}\")\n        \n        # Validate rendering quality for medical use\n        rendering_config = visual_config.get('rendering', {})\n        if rendering_config.get('quality_level') not in ['high', 'ultra']:\n            warnings.append(\"Rendering quality should be 'high' or 'ultra' for medical accuracy\")\n        \n        if not rendering_config.get('anti_aliasing', False):\n            warnings.append(\"Anti-aliasing should be enabled for medical visualization\")\n        \n        if errors:\n            return self._create_validation_result('FAILED', errors, warnings)\n        elif warnings:\n            return self._create_validation_result('WARNING', [], warnings)\n        else:\n            return self._create_validation_result('PASSED', [], [])\n    \n    def validate_educational_accuracy(self, medical_data: Dict[str, Any],\n                                    educational_content: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        Validate educational content medical accuracy\n        \"\"\"\n        errors = []\n        warnings = []\n        \n        rhythm = medical_data.get('rhythm_classification', '')\n        significance = medical_data.get('clinical_significance', '')\n        \n        # Validate rhythm explanation accuracy\n        rhythm_explanation = educational_content.get('rhythm_explanation', '').lower()\n        if rhythm and rhythm.replace('_', ' ') not in rhythm_explanation:\n            errors.append(f\"Rhythm explanation doesn't mention {rhythm}\")\n        \n        # Validate clinical significance emphasis\n        significance_explanation = educational_content.get('clinical_significance_explanation', '').lower()\n        \n        if significance == 'critical':\n            critical_keywords = ['critical', 'emergency', 'immediate', 'life-threatening', 'urgent']\n            if not any(keyword in significance_explanation for keyword in critical_keywords):\n                errors.append(\"Critical findings not properly emphasized in educational content\")\n        \n        # Validate key teaching points accuracy\n        teaching_points = educational_content.get('key_teaching_points', [])\n        \n        if rhythm == 'atrial_fibrillation':\n            afib_keywords = ['irregular', 'fibrillation', 'atrial']\n            points_text = ' '.join(teaching_points).lower()\n            missing_keywords = [kw for kw in afib_keywords if kw not in points_text]\n            if missing_keywords:\n                warnings.append(f\"AFib teaching points missing keywords: {missing_keywords}\")\n        \n        elif rhythm == 'ventricular_tachycardia':\n            vtach_keywords = ['ventricular', 'tachycardia', 'wide', 'dangerous']\n            points_text = ' '.join(teaching_points).lower()\n            missing_keywords = [kw for kw in vtach_keywords if kw not in points_text]\n            if missing_keywords:\n                warnings.append(f\"VTach teaching points missing keywords: {missing_keywords}\")\n        \n        # Validate narration timing synchronization\n        narration_timing = educational_content.get('narration_timing', [])\n        cardiac_cycle = medical_data.get('conduction_timing', {}).get('cardiac_cycle_ms', 1000)\n        \n        for cue in narration_timing:\n            timestamp = cue.get('timestamp_ms', 0)\n            if timestamp > cardiac_cycle:\n                errors.append(f\"Narration cue at {timestamp}ms exceeds cardiac cycle {cardiac_cycle}ms\")\n        \n        # Validate emphasis levels for critical rhythms\n        if significance == 'critical':\n            critical_cues = [cue for cue in narration_timing if cue.get('emphasis_level') == 'critical']\n            if not critical_cues:\n                warnings.append(\"No critical emphasis cues for critical rhythm\")\n        \n        # Validate accessibility compliance\n        accessibility = educational_content.get('accessibility', {})\n        \n        if not accessibility.get('screen_reader_compatible', False):\n            errors.append(\"Educational content must be screen reader compatible\")\n        \n        if not accessibility.get('captions', False):\n            errors.append(\"Educational content must include captions\")\n        \n        # Validate learning progression logic\n        learning_progression = educational_content.get('learning_progression', {})\n        \n        prerequisites = learning_progression.get('prerequisite_concepts', [])\n        if not prerequisites:\n            warnings.append(\"No prerequisite concepts specified\")\n        \n        mastery_indicators = learning_progression.get('mastery_indicators', [])\n        if not mastery_indicators:\n            warnings.append(\"No mastery indicators specified\")\n        \n        if errors:\n            return self._create_validation_result('FAILED', errors, warnings)\n        elif warnings:\n            return self._create_validation_result('WARNING', [], warnings)\n        else:\n            return self._create_validation_result('PASSED', [], [])\n    \n    def _validate_heart_rate(self, medical_data: Dict[str, Any]) -> Dict[str, List[str]]:\n        \"\"\"Validate heart rate is physiologically possible\"\"\"\n        errors = []\n        warnings = []\n        \n        heart_rate = medical_data.get('heart_rate', 0)\n        \n        if heart_rate < self.clinical_thresholds['heart_rate']['min']:\n            errors.append(f\"Heart rate {heart_rate} below minimum viable ({self.clinical_thresholds['heart_rate']['min']})\")\n        elif heart_rate < 40:\n            warnings.append(f\"Very low heart rate: {heart_rate} BPM\")\n        \n        if heart_rate > self.clinical_thresholds['heart_rate']['max']:\n            errors.append(f\"Heart rate {heart_rate} above maximum possible ({self.clinical_thresholds['heart_rate']['max']})\")\n        elif heart_rate > 200:\n            warnings.append(f\"Very high heart rate: {heart_rate} BPM\")\n        \n        # Validate heart rate matches rhythm classification\n        rhythm = medical_data.get('rhythm_classification', '')\n        \n        if rhythm == 'sinus_bradycardia' and heart_rate >= 60:\n            errors.append(f\"Sinus bradycardia requires heart rate <60 BPM, got {heart_rate}\")\n        \n        if rhythm == 'sinus_tachycardia' and heart_rate <= 100:\n            errors.append(f\"Sinus tachycardia requires heart rate >100 BPM, got {heart_rate}\")\n        \n        if rhythm == 'ventricular_tachycardia' and heart_rate < 150:\n            warnings.append(f\"VTach typically >150 BPM, got {heart_rate}\")\n        \n        return {'errors': errors, 'warnings': warnings}\n    \n    def _validate_conduction_timing(self, medical_data: Dict[str, Any]) -> Dict[str, List[str]]:\n        \"\"\"Validate conduction timing is physiologically accurate\"\"\"\n        errors = []\n        warnings = []\n        \n        timing = medical_data.get('conduction_timing', {})\n        heart_rate = medical_data.get('heart_rate', 72)\n        \n        # Validate cardiac cycle matches heart rate\n        expected_cycle = 60000 / heart_rate  # Convert BPM to ms\n        actual_cycle = timing.get('cardiac_cycle_ms', 0)\n        \n        cycle_tolerance = 100  # 100ms tolerance\n        if abs(expected_cycle - actual_cycle) > cycle_tolerance:\n            errors.append(f\"Cardiac cycle {actual_cycle}ms doesn't match heart rate {heart_rate} BPM (expected ~{expected_cycle:.0f}ms)\")\n        \n        # Validate SA-AV delay\n        sa_av_delay = timing.get('sa_to_av_delay', 0)\n        if sa_av_delay < 50 or sa_av_delay > 300:\n            errors.append(f\"SA-AV delay {sa_av_delay}ms outside normal range (50-300ms)\")\n        \n        # Validate AV-His delay\n        av_his_delay = timing.get('av_to_his_delay', 0)\n        if av_his_delay < 30 or av_his_delay > 100:\n            errors.append(f\"AV-His delay {av_his_delay}ms outside normal range (30-100ms)\")\n        \n        # Validate His-Purkinje delay\n        his_purkinje_delay = timing.get('his_to_purkinje_delay', 0)\n        if his_purkinje_delay < 10 or his_purkinje_delay > 60:\n            errors.append(f\"His-Purkinje delay {his_purkinje_delay}ms outside normal range (10-60ms)\")\n        \n        # Validate QRS duration\n        qrs_duration = timing.get('qrs_duration', 0)\n        if qrs_duration < 40 or qrs_duration > 200:\n            errors.append(f\"QRS duration {qrs_duration}ms outside possible range (40-200ms)\")\n        \n        return {'errors': errors, 'warnings': warnings}\n    \n    def _validate_clinical_significance(self, medical_data: Dict[str, Any]) -> Dict[str, List[str]]:\n        \"\"\"Validate clinical significance matches rhythm and parameters\"\"\"\n        errors = []\n        warnings = []\n        \n        rhythm = medical_data.get('rhythm_classification', '')\n        significance = medical_data.get('clinical_significance', '')\n        heart_rate = medical_data.get('heart_rate', 72)\n        \n        # Critical rhythms must be marked as critical\n        if rhythm in self.critical_rhythms and significance != 'critical':\n            errors.append(f\"{rhythm} must be classified as critical, not {significance}\")\n        \n        # Validate significance is appropriate for rhythm\n        if rhythm in self.rhythm_significance_map:\n            allowed_significance = self.rhythm_significance_map[rhythm]\n            if isinstance(allowed_significance, list):\n                if significance not in allowed_significance:\n                    warnings.append(f\"{rhythm} significance '{significance}' unusual, expected one of: {allowed_significance}\")\n            else:\n                if significance != allowed_significance:\n                    errors.append(f\"{rhythm} should be '{allowed_significance}', not '{significance}'\")\n        \n        # Heart rate-based significance validation\n        if heart_rate < 30 and significance not in ['urgent', 'critical']:\n            errors.append(f\"Heart rate {heart_rate} BPM should be urgent or critical, not {significance}\")\n        \n        if heart_rate > 200 and significance == 'normal':\n            errors.append(f\"Heart rate {heart_rate} BPM should not be classified as normal\")\n        \n        return {'errors': errors, 'warnings': warnings}\n    \n    def _validate_chamber_coordination(self, medical_data: Dict[str, Any]) -> Dict[str, List[str]]:\n        \"\"\"Validate chamber coordination logic\"\"\"\n        errors = []\n        \n        coordination = medical_data.get('chamber_coordination', {})\n        rhythm = medical_data.get('rhythm_classification', '')\n        \n        # Atrial fibrillation should have no atrial mechanical function\n        if rhythm == 'atrial_fibrillation':\n            if coordination.get('atrial_contraction', True):\n                errors.append(\"Atrial fibrillation should not have effective atrial contraction\")\n            if coordination.get('av_synchrony', True):\n                errors.append(\"Atrial fibrillation should not have AV synchrony\")\n            if coordination.get('sequential_activation', True):\n                errors.append(\"Atrial fibrillation should not have sequential activation\")\n        \n        # Normal sinus rhythm should have coordinated function\n        if rhythm == 'normal_sinus':\n            if not coordination.get('atrial_contraction', False):\n                errors.append(\"Normal sinus rhythm should have atrial contraction\")\n            if not coordination.get('ventricular_contraction', False):\n                errors.append(\"Normal sinus rhythm should have ventricular contraction\")\n            if not coordination.get('av_synchrony', False):\n                errors.append(\"Normal sinus rhythm should have AV synchrony\")\n            if not coordination.get('sequential_activation', False):\n                errors.append(\"Normal sinus rhythm should have sequential activation\")\n        \n        return {'errors': errors, 'warnings': []}\n    \n    def _validate_intervals(self, medical_data: Dict[str, Any]) -> Dict[str, List[str]]:\n        \"\"\"Validate EKG interval measurements\"\"\"\n        errors = []\n        warnings = []\n        \n        intervals = medical_data.get('intervals', {})\n        rhythm = medical_data.get('rhythm_classification', '')\n        \n        # PR interval validation\n        pr_interval = intervals.get('pr_interval', 0)\n        if pr_interval < self.clinical_thresholds['pr_interval']['min']:\n            errors.append(f\"PR interval {pr_interval}ms below minimum possible ({self.clinical_thresholds['pr_interval']['min']})\")\n        elif pr_interval < 120:\n            warnings.append(f\"Short PR interval: {pr_interval}ms\")\n        \n        if pr_interval > self.clinical_thresholds['pr_interval']['max']:\n            errors.append(f\"PR interval {pr_interval}ms above maximum possible ({self.clinical_thresholds['pr_interval']['max']})\")\n        elif pr_interval > 200:\n            if rhythm != 'heart_block':\n                warnings.append(f\"Prolonged PR interval {pr_interval}ms suggests heart block\")\n        \n        # QRS width validation\n        qrs_width = intervals.get('qrs_width', 0)\n        if qrs_width < self.clinical_thresholds['qrs_duration']['min']:\n            errors.append(f\"QRS width {qrs_width}ms below minimum possible ({self.clinical_thresholds['qrs_duration']['min']})\")\n        \n        if qrs_width > self.clinical_thresholds['qrs_duration']['max']:\n            errors.append(f\"QRS width {qrs_width}ms above maximum possible ({self.clinical_thresholds['qrs_duration']['max']})\")\n        elif qrs_width > 120 and 'ventricular' not in rhythm:\n            warnings.append(f\"Wide QRS ({qrs_width}ms) may indicate ventricular origin or bundle branch block\")\n        \n        # QT interval validation\n        qt_corrected = intervals.get('qt_corrected', 0)\n        if qt_corrected > 500:\n            warnings.append(f\"Prolonged QTc {qt_corrected}ms increases risk of torsades de pointes\")\n        \n        return {'errors': errors, 'warnings': warnings}\n    \n    def _validate_medical_safety(self, medical_data: Dict[str, Any]) -> Dict[str, List[str]]:\n        \"\"\"Critical medical safety validation\"\"\"\n        errors = []\n        \n        rhythm = medical_data.get('rhythm_classification', '')\n        significance = medical_data.get('clinical_significance', '')\n        heart_rate = medical_data.get('heart_rate', 0)\n        \n        # CRITICAL: Never classify dangerous rhythms as normal\n        dangerous_rhythms = [\n            'ventricular_tachycardia',\n            'ventricular_fibrillation',\n            'complete_heart_block',\n            'asystole'\n        ]\n        \n        if rhythm in dangerous_rhythms and significance == 'normal':\n            errors.append(f\"SAFETY VIOLATION: {rhythm} classified as normal - this is medically dangerous\")\n        \n        # CRITICAL: Extremely abnormal heart rates\n        if heart_rate < 25 and significance == 'normal':\n            errors.append(f\"SAFETY VIOLATION: Heart rate {heart_rate} BPM classified as normal\")\n        \n        if heart_rate > 250 and significance in ['normal', 'monitor']:\n            errors.append(f\"SAFETY VIOLATION: Heart rate {heart_rate} BPM not flagged as urgent/critical\")\n        \n        # CRITICAL: Validate treatment recommendations are appropriate\n        treatment_considerations = medical_data.get('clinical_context', {}).get('treatment_considerations', [])\n        \n        if rhythm == 'ventricular_tachycardia':\n            urgent_keywords = ['immediate', 'emergency', 'cardioversion', 'defibrillation']\n            has_urgent_treatment = any(\n                any(keyword in treatment.lower() for keyword in urgent_keywords)\n                for treatment in treatment_considerations\n            )\n            if not has_urgent_treatment:\n                errors.append(\"SAFETY VIOLATION: VTach missing urgent treatment recommendations\")\n        \n        return {'errors': errors, 'warnings': []}\n    \n    def _create_validation_result(self, status: str, errors: List[str], warnings: List[str]) -> Dict[str, Any]:\n        \"\"\"Create standardized validation result\"\"\"\n        return {\n            'status': status,\n            'errors': errors,\n            'warnings': warnings,\n            'timestamp': '2024-01-01T00:00:00Z',  # Would use actual timestamp\n            'blocking': status == 'FAILED',\n            'medical_safety_score': 1.0 if status == 'PASSED' else (0.5 if status == 'WARNING' else 0.0)\n        }\n\ndef main():\n    \"\"\"Main hook entry point\"\"\"\n    if len(sys.argv) < 2:\n        print(json.dumps({\n            \"status\": \"ERROR\",\n            \"error\": \"No validation data provided\"\n        }))\n        return\n    \n    try:\n        hook_data = json.loads(sys.argv[1])\n        validator = MedicalQualityAssurance()\n        \n        validation_type = hook_data.get('validation_type', 'medical_analysis')\n        \n        if validation_type == 'medical_analysis':\n            result = validator.validate_medical_analysis(hook_data.get('data', {}))\n        elif validation_type == 'visualization_sync':\n            result = validator.validate_visualization_sync(\n                hook_data.get('medical_data', {}),\n                hook_data.get('visual_config', {})\n            )\n        elif validation_type == 'educational_accuracy':\n            result = validator.validate_educational_accuracy(\n                hook_data.get('medical_data', {}),\n                hook_data.get('educational_content', {})\n            )\n        else:\n            result = {\n                \"status\": \"ERROR\",\n                \"error\": f\"Unknown validation type: {validation_type}\"\n            }\n        \n        print(json.dumps(result))\n        \n    except Exception as e:\n        logger.error(f\"Medical validation failed: {str(e)}\")\n        print(json.dumps({\n            \"status\": \"ERROR\",\n            \"error\": f\"Medical validation failed: {str(e)}\"\n        }))\n\nif __name__ == \"__main__\":\n    main()"